# OpenClaw image
OPENCLAW_IMAGE=ghcr.io/openclaw/openclaw:main

# Models are fixed in:
# - config/gpt/openclaw.json
# - config/claude/openclaw.json
# - config/gemini/openclaw.json
# - config/grok/openclaw.json

# Gateway tokens (set long random strings)
GPT_GATEWAY_TOKEN=replace_with_random_token_for_gpt
CLAUDE_GATEWAY_TOKEN=replace_with_random_token_for_claude
GEMINI_GATEWAY_TOKEN=replace_with_random_token_for_gemini
GROK_GATEWAY_TOKEN=replace_with_random_token_for_grok

# Host ports (gateway + bridge) for each agent
GPT_GATEWAY_PORT=18789
GPT_BRIDGE_PORT=18790
CLAUDE_GATEWAY_PORT=18889
CLAUDE_BRIDGE_PORT=18890
GEMINI_GATEWAY_PORT=18989
GEMINI_BRIDGE_PORT=18990
GROK_GATEWAY_PORT=19089
GROK_BRIDGE_PORT=19090

# LLM provider API keys (non-Gemini)
OPENAI_API_KEY=replace_with_openai_key
ANTHROPIC_API_KEY=replace_with_anthropic_key
XAI_API_KEY=replace_with_xai_key

# Optional Moltbook API key bootstrap (used when state volume is empty)
# If set, entrypoint will auto-create ./state/*/moltbook-credentials.json
GPT_MOLTBOOK_API_KEY=
GPT_MOLTBOOK_AGENT_NAME=openclaw-gpt
CLAUDE_MOLTBOOK_API_KEY=
CLAUDE_MOLTBOOK_AGENT_NAME=openclaw-claude
GEMINI_MOLTBOOK_API_KEY=
GEMINI_MOLTBOOK_AGENT_NAME=openclaw-gemini
GROK_MOLTBOOK_API_KEY=
GROK_MOLTBOOK_AGENT_NAME=openclaw-grok

# Gemini via Vertex AI
# 1) Save your service account JSON to GEMINI_VERTEX_CREDENTIALS_FILE
# 2) Put the GCP project/location here
GEMINI_VERTEX_CREDENTIALS_FILE=./secrets/gemini-vertex-sa.json
GEMINI_VERTEX_PROJECT_ID=replace_with_gcp_project_id
GEMINI_VERTEX_LOCATION=us-central1

# Optional: keep full service-account JSON in .env, then run:
# ./scripts/write-gemini-vertex-sa.sh
# Use a single-line JSON string with escaped newlines for private_key.
# GEMINI_VERTEX_SA_JSON={"type":"service_account","private_key":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n",...}

# Telegram controller (optional)
# Restrict access to specific chat IDs only (comma-separated).
# Example chat id lookup command:
#   curl -s "https://api.telegram.org/bot<token>/getUpdates" | jq
TELEGRAM_BOT_TOKEN=
TELEGRAM_ALLOWED_CHAT_IDS=
TELEGRAM_POLL_TIMEOUT_SECONDS=30
TELEGRAM_COMMAND_TIMEOUT_SECONDS=900
TELEGRAM_MAX_OUTPUT_CHARS=3500
# Keep false unless you explicitly want telegram to trigger merge.
TELEGRAM_ENABLE_E2E_MERGE=false
# If true, human commands can target only AGENT_LEADER.
TELEGRAM_LEADER_ONLY_MODE=true
# If true, disable manual dev commands and keep only approval + emergency control.
TELEGRAM_MINIMAL_COMMAND_MODE=true
# If true, [HUMAN_REQUEST] signals require agent consensus before opening a pending request.
TELEGRAM_AGENT_CONSENSUS_REQUIRED=true
# Minimum approvals out of 4 agents (recommended: 3).
TELEGRAM_AGENT_CONSENSUS_MIN=3
# Comma-separated command keys that require manual approval first.
# Supported keys in this controller: pr, e2e_merge, commit, e2e, status, ask
TELEGRAM_REQUIRE_APPROVAL_COMMANDS=pr,e2e_merge
# If true, when a command fails with blocker patterns (credentials/permission/rate-limit),
# controller auto-creates approval request for human intervention.
TELEGRAM_AUTO_REQUEST_ON_BLOCKER=true
# If true, blocks /commit /pr /e2e /e2e_merge while any request is pending.
TELEGRAM_PAUSE_DEV_WHEN_PENDING=true
# If true, runs a planning-only review cycle while waiting for human decision.
TELEGRAM_AUTO_PLAN_REVIEW_ON_PENDING=true
# Repo snapshot used for plan-review context.
TELEGRAM_PLAN_REVIEW_REPO=workdirs/gpt
# Watchdog: periodically checks all 4 agents and escalates immediately on failures.
TELEGRAM_WATCHDOG_ENABLED=true
TELEGRAM_WATCHDOG_INTERVAL_SECONDS=300
TELEGRAM_WATCHDOG_TIMEOUT_SECONDS=240
TELEGRAM_WATCHDOG_ALERT_COOLDOWN_SECONDS=600
TELEGRAM_WATCHDOG_PROMPT=한 문장으로 hello
TELEGRAM_WATCHDOG_CHECK_MOLTBOOK=true

# Optional leader override (can also be set in autonomy/config.env).
AGENT_LEADER=gemini
